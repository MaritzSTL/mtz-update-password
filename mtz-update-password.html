<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">
<link rel="import" href="mtz-validation-status.html">
<link rel="import" href="mtz-password-validator.html">

<!--
`mtz-update-password`
Takes a password in from the user and validates it against a set of requirements.

### Styling
Custom property | Description | Default
----------------|-------------|----------
`--mtz-update-password` | A mixin for styling this element | {}
`--mtz-update-password-valid-status` | A mixin for styling the valid-status group | {}
`--mtz-update-password-input` | A mixin to style the password input field | {}
`--mtz-update-password-retype-input` | A mixin to style the retype password input field | {}
`--mtz-update-password-input-fields` | A mixin to style the grouping element around both input fields | {}

@demo demo/index.html
-->
<dom-module id="mtz-update-password">
  <template>
    <style>
      :host {
        @apply --mtz-update-password;
      }
      .valid-status {
        @apply --mtz-update-password-valid-status;
      }
      #password {
        @apply --mtz-update-password-input;
      }
      #retype-password {
        @apply --mtz-update-password-retype-input;
      }
      .password-input {
        @apply --mtz-update-password-input-fields;
      }
    </style>

    <slot name="title"></slot>
    <div class="password-input">
      <mtz-password-validator
        allowed-characters="[[allowedCharacters]]"
        allowed-symbols="[[allowedSymbols]]"
        maxlength="[[maxlength]]"
        minlength="[[minlength]]"
        min-letters="[[minLetters]]"
        min-numbers="[[minNumbers]]"
        min-symbols="[[minSymbols]]"
        min-upper="[[minUpper]]"
        required="[[required]]"
        validation-errors="{{validationErrors}}"
        retype-value="{{retypeValue}}"
        disable-retype="{{disableRetype}}"
      ></mtz-password-validator>
      <paper-input
        id="password"
        type="password"
        validator="mtz-password-validator"
        value="{{value}}"
        label="[[passwordLabel]]"
        no-label-float="[[noLabelFloat]]"
        placeholder="[[placeholder]]"
        always-float-label="[[alwaysFloatLabel]]"
        autofocus="[[autofocus]]"
        maxlength="[[maxlength]]"
        minlength="[[minlength]]"
        auto-validate="[[autoValidate]]"
        required$="[[required]]"
        autocomplete="[[autocomplete]]"
      ></paper-input>
      <template
        is="dom-if"
        if="[[!disableRetype]]">
        <paper-input
          id="retype-password"
          type="password"
          value="{{retypeValue}}"
          label="[[retypePasswordLabel]]"
          no-label-float="[[retypeNoLabelFloat]]"
          placeholder="[[retypePlaceholder]]"
          always-float-label="[[retypeAlwaysFloatLabel]]"
          autofocus="[[retypeAutofocus]]"
          pattern="[[__getPattern(value, allowedSymbols)]]"
          required$="[[__toBoolean(value)]]"
          maxlength="[[maxlength]]"
          minlength="[[minlength]]"
          invalid="{{validationErrors.matching}}"
          on-invalid-changed="__updateValidity"
          auto-validate="[[autoValidate]]"
          autocomplete="[[autocomplete]]"
        ></paper-input>
      </template>
    </div>

    <slot></slot>

    <template is="dom-if" if="[[!disableValidStatus]]">
      <mtz-validation-status
        errors="[[validationErrors]]"
        invalid-icon="[[invalidStatusIcon]]"
        valid-icon="[[validStatusIcon]]"
        messages="[[__filterMessages(validationMessages, disableRetype)]]"
        values="[[__validationValues]]"
      ></mtz-validation-status>
    </template>
  </template>

  <script>
    Polymer({
      is: 'mtz-update-password',
      behaviors: [
        Polymer.IronValidatableBehavior,
      ],
      observers: [
        '__validateRetype(disableRetype, validationErrors.matching)',
        '__setInvalid(validationErrors, validationErrors.*)',
      ],
      properties: {
        autoValidate: Boolean,
        /* Allowed characters regex pattern, gets combined with symbols to build allowedPattern */
        allowedCharacters: {
          type: String,
          value: 'a-zA-Z0-9',
        },
        /* Allowed symbols regex pattern, gets combined with characters to build allowedPattern */
        allowedSymbols: {
          type: String,
          value: '\\.\\+\\-!;:@#\\$%\\^&\\*\\(\\)_=',
        },
        /* AlwaysFloatLabel override for the password input */
        alwaysFloatLabel: {
          type: Boolean,
          value: false,
        },
        /* Passthrough for autocomplete */
        autocomplete: {
          type: String,
          value: 'new-password',
        },
        /* AutoFocus override for the password input */
        autofocus: {
          type: Boolean,
          value: false,
        },
        /* Removes the status section showing if you've hit all the requirements or not */
        disableValidStatus: {
          type: Boolean,
          value: false,
        },
        /* Removes the requirement for entering a password twice */
        disableRetype: {
          type: Boolean,
          value: false,
        },
        /* Maximum number of characters allowed */
        maxlength: {
          type: Number,
          value: 20,
        },
        /* Minimum number of characters required */
        minlength: {
          type: Number,
          value: 8,
        },
        /* Minimum number of capital letters required */
        minUpper: {
          type: Number,
          value: 0,
        },
        /* Minimum number of letters required, regardless of case */
        minLetters: {
          type: Number,
          value: 2,
        },
        /* Minimum number of numbers required */
        minNumbers: {
          type: Number,
          value: 2,
        },
        /* Minimum number of symbols required, valid symbols are defined by the symbols property */
        minSymbols: {
          type: Number,
          value: 0,
        },
        value: {
          type: String,
          notify: true,
          observer: '__valueChanged',
        },
        /* The second user entered password to validate against */
        retypeValue: {
          type: String,
          notify: true,
        },
        required: {
          type: Boolean,
          value: false,
        },
        /* NoLabelFloat override for the password input */
        noLabelFloat: String,
        invalid: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          observer: '__invalidChanged'
        },
        /* The icon to use when a status message is invalid */
        invalidStatusIcon: String,
        /* Label override for the password input */
        passwordLabel: {
          type: String,
          value: 'New Password',
        },
        /* Placeholder override for the password input */
        placeholder: String,
        /* AlwaysFloatLabel override for the retype password input */
        retypeAlwaysFloatLabel: {
          type: Boolean,
          value: false,
        },
        /* AutoFocus override for the retype password input */
        retypeAutofocus: {
          type: Boolean,
          value: false,
        },
        /* NoLabelFloat override for the retype password input */
        retypeNoLabelFloat: String,
        /* Label override for the retype password input */
        retypePasswordLabel: {
          type: String,
          value: 'Confirm New Password',
        },
        /* Placeholder override for the retype password input */
        retypePlaceholder: String,
        /* The icon to use when a status message is valid */
        validStatusIcon: String,
        /* The current validation errors */
        validationErrors: {
          type: Object,
          notify: true,
        },
        /* The messages to display when matching against an error */
        validationMessages: {
          type: Array,
          value() {
            return [
              {
                key: 'matching',
                message: 'Passwords must match',
              },
              {
                key: 'maxlength',
                message: 'A maximum of ${maxlength} characters',
              },
              {
                key: 'minlength',
                message: 'A minimum of ${minlength} characters',
              },
              {
                key: 'minUpper',
                message: 'At least ${minUpper} uppercase',
              },
              {
                key: 'minLetters',
                message: 'At least ${minLetters} ${lettersText}',
              },
              {
                key: 'minNumbers',
                message: 'At least ${minNumbers} ${numbersText}',
              },
              {
                key: 'minSymbols',
                message: 'At least ${minSymbols} ${symbolsText}',
              },
            ];
          },
        },
        /* The values to pass to the `<mtz-validation-status>` element, constructed from the flags. */
        __validationValues: {
          type: Object,
          computed: `__buildValidationValues(allowedCharacters, allowedSymbols, maxlength, minlength, minUpper,
            minLetters, minNumbers, minSymbols)`,
        },
      },
      /**
       * Constructs the _validationValues object from the requirements.
       *
       * @protected
       * @param {String} allowedCharacters
       * @param {String} allowedSymbols
       * @param {Number} maxlength
       * @param {Number} minlength
       * @param {Number} minUpper
       * @param {Number} minLetters
       * @param {Number} minNumbers
       * @param {Number} minSymbols
       * @return {Object}
       */
      __buildValidationValues(allowedCharacters, allowedSymbols, maxlength, minlength, minUpper, minLetters,
        minNumbers, minSymbols) {
        return {
          allowedCharacters,
          allowedSymbols,
          maxlength,
          minlength,
          minUpper,
          minLetters,
          minNumbers,
          minSymbols,
          lettersText: minLetters > 1 ? 'letters' : 'letter',
          numbersText: minNumbers > 1 ? 'numbers' : 'number',
          symbolsText: minSymbols > 1 ? 'symbols' : 'symbol',
        };
      },
      /**
       * Removes retype validation message when retype is disabled.
       * @private
       *
       * @param {Object[]} messages
       * @param {Boolean} disableRetype
       * @return {Object[]}
       */
      __filterMessages(messages, disableRetype) {
        return messages.filter((message) => {
          return !disableRetype || (message.key !== 'matching');
        });
      },
      /**
       * Takes a value and converts it to a safe pattern to use with paper-input.
       *
       * @protected
       * @param {String} value
       * @param {String} symbols
       * @return {String}
       */
      __getPattern(value, symbols) {
        // Take our value and check to see what symbols require a '\' prefix, then inject it as needed.
        return (value || '').replace(
          new RegExp(`([${symbols}])`, 'g'),
          (str, symbol) => {
            return (symbols.match(`\\\\\\${symbol}`) || []).length > 0 ?
              `\\${symbol}` :
              symbol;
          });
      },
      /**
       * Ensures that the password is set to invalid when this element is invalid.
       * @private
       *
       * @param {Boolean} invalid
       */
      __invalidChanged(invalid) {
        if (invalid && !this.validationErrors.matching)
          this.$.password.invalid = invalid;
      },
      /**
       * Takes a value and casts it to a Boolean.
       * @private
       *
       * @param {Object} value
       * @return {Boolean}
       */
      __toBoolean(value) {
        return Boolean(value);
      },
      /**
       * Sets invalid on this element when any of the errors are set in the validationErrors object.
       * @private
       *
       * @param {Object} errors
       */
      __setInvalid(validationErrors) {
        const error = Object.keys(validationErrors).
          some((key) => validationErrors[key]);

        this.invalid = this.value ? error : this.required;
      },
      /**
       * Calls validate() on the retype-password field if it exists.
       * @private
       *
       * @param {Boolean} disabled - whether or not retype-password is enabled
       */
      __validateRetype(disabled) {
        if (disabled) return;
        const retype = this.$$('#retype-password');
        if (retype && retype.validate) retype.validate();
      },
      /**
       * Runs the invalid check every time the value changes since it normally doesn't when less than minlength.
       * @private
       */
      __valueChanged() {
        this.__setInvalid(this.validationErrors);
      },
      /**
       * Calls validate on the password field if there is a retype value and the retype password field justify-content
       *  went valid.
       * @private
       *
       * @param {CustomEvent} event
       */
      __updateValidity(event) {
        if (this.retypeValue && !event.detail.value)
          this.$.password.validate();
      }
    });
  </script>
</dom-module>
