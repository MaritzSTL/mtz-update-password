<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>mtz-update-password test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="../mtz-update-password.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <mtz-update-password></mtz-update-password>
      </template>
    </test-fixture>

    <script>
      describe('mtz-update-password', () => {
        let element;

        beforeEach(() => element = fixture('basic'));

        // Template
        describe('paper-input#password', () => {
          let input;

          beforeEach(done => flush(() => {
            input = element.$.password;
            done();
          }));

          it('should have allowedPattern populated with _buildAllowedPattern', () =>
            expect(input.allowedPattern).to.
            equal(element._buildAllowedPattern(element.allowedCharacters, element.allowedSymbols)));
          it('should update this.value when changed', done => {
            input.value = 'foo';
            flush(() => {
              expect(element.value).to.equal('foo');
              done();
            });
          });
        });
        describe('paper-input#retype-password', () => {
          let input;

          beforeEach(done => flush(() => {
            input = element.$$('#retype-password');
            element.value = 'value';
            done();
          }));

          it('should have allowedPattern populated with _buildAllowedPattern', () =>
            expect(input.allowedPattern).to.
            equal(element._buildAllowedPattern(element.allowedCharacters, element.allowedSymbols)));
          it('should have required and pattern set based on value', () => {
            element.value = '';
            expect(input.pattern).to.equal(element._asPattern(element.value, element.allowedSymbols));
            expect(input.required).to.equal(false);
            element.value = 'foo';
            expect(input.pattern).to.equal(element._asPattern(element.value, element.allowedSymbols));
            expect(input.required).to.equal(true);
          });
          it('should be removed when disableRetype', done => {
            element.disableRetype = true;

            flush(() => {
              expect(element.$$('#retype-password')).to.not.be.defined;
              done();
            });
          });
          it('should update this.retypeValue when changed', done => {
            input.value = 'foo';
            flush(() => {
              expect(element.retypeValue).to.equal('foo');
              done();
            });
          });
        });
        // Private Functions
        describe('_asBoolean(value)', () => {
          it('should convert the provided value to a boolean', () => {
            expect(element._asBoolean('')).to.equal(Boolean(''));
            expect(element._asBoolean('asdf')).to.equal(Boolean('asdf'));
            expect(element._asBoolean({})).to.equal(Boolean({}));
            expect(element._asBoolean(false)).to.equal(false);
          });
        });
        describe('_asPattern(value, symbols)', () => {
          it('should not modify a value that does not contain symbols', () =>
            expect(element._asPattern('foo', element.allowedSymbols)).to.equal('foo'));
          it('should not modify symbols that do not require a leading "\\"', () =>
            expect(element._asPattern('foo!bar!', element.allowedSymbols)).to.equal('foo!bar!'));
          it('should replace symbols that require a leading "\\"', () =>
            expect(element._asPattern('foo*bar$', element.allowedSymbols)).to.equal('foo\\*bar\\$'));
        });
        describe('_buildAllowedPattern(characters, symbols)', () => {
          it('should return the pattern containing characters and symbols', () =>
            expect(element._buildAllowedPattern('a-z', '!@')).to.equal('[a-z!@]'));
        });
        describe('_buildValidationValues(allowedCharacters, allowedSymbols, maxlength, minlength, minUpper, ' +
          'minLetters, minNumbers, minSymbols)', () => {
          it('should return the requirements as an object', () => {
            expect(element._validationValues.allowedCharacters).to.equal(element.allowedCharacters);
            expect(element._validationValues.allowedSymbols).to.equal(element.allowedSymbols);
            expect(element._validationValues.maxlength).to.equal(element.maxlength);
            expect(element._validationValues.minlength).to.equal(element.minlength);
            expect(element._validationValues.minUpper).to.equal(element.minUpper);
            expect(element._validationValues.minLetters).to.equal(element.minLetters);
            expect(element._validationValues.minNumbers).to.equal(element.minNumbers);
            expect(element._validationValues.minSymbols).to.equal(element.minSymbols);
          });
          it('should compute pluralized strings for symbols, numbers, and letters', () => {
            element.minLetters = 2;
            element.minNumbers = 2;
            element.minSymbols = 2;
            expect(element._validationValues.lettersText).to.equal('letters');
            expect(element._validationValues.numbersText).to.equal('numbers');
            expect(element._validationValues.symbolsText).to.equal('symbols');
          });
          it('should compute singular strings for symbols, numbers, and letters', () => {
            element.minLetters = 1;
            element.minNumbers = 1;
            element.minSymbols = 1;
            expect(element._validationValues.lettersText).to.equal('letter');
            expect(element._validationValues.numbersText).to.equal('number');
            expect(element._validationValues.symbolsText).to.equal('symbol');
          });
        });
        describe('_getValidationMessages(disableRetype, validationMessages)', () => {
          it('should return validationMessages when !disableRetype', () =>
            expect(element._getValidationMessages(false, element.validationMessages)).
              to.deep.equal(element.validationMessages));
          it('should return validationMessages without matching when disableRetype', () => {
            const messages = [
              {
                key: 'matching'
              },
              {
                key: 'foo'
              }
            ];
            expect(element._getValidationMessages(true, messages)). to.deep.
              equal([{key: 'foo'}]);
          });
        });
        describe('_getValidity(value)', () => {
          beforeEach(done => flush(() => {
            element.minlength = 0;
            element.minLetters = 0;
            element.minUpper = 0;
            element.minSymbols = 0;
            element.minNumbers = 0;
            element.$.password.validate = sinon.stub();
            element.$.password.validate.returns(true);
            element.$$('#retype-password').validate = sinon.stub();
            element.$$('#retype-password').validate.returns(true);
            done();
          }));

          it('should call validate() on #password', () => {
            element._getValidity();
            expect(element.$.password.validate.calledOnce).to.equal(true);
          });
          it('should call validate() on #retype-password if !disableRetype', () => {
            element._getValidity();
            expect(element.$$('#retype-password').validate.calledOnce).to.equal(true);
          });
          it('should not call validate() on #retype-password if disableRetype', done => {
            element.disableRetype = true;

            flush(() => {
              element._getValidity();
              expect(element.$$('#retype-password')).to.not.be.defined;
              done();
            });
          });
          it('should return true when a value is provided and there are no errors', () => {
            element.value = 'foo';
            element.retypeValue = 'foo';
            expect(element._getValidity()).to.equal(true);
          });
          it('should return false when a value is provided and there are errors', () => {
            element.maxlength = 2;
            element.value = 'foo';
            element.retypeValue = 'foo';
            expect(element._getValidity()).to.equal(false);
          });
          it('should return true when there is no value and !required', () => {
            element.required = false;
            expect(element._getValidity()).to.equal(true);
          });
          it('should return false when there is no value and required', () => {
            element.required = true;
            expect(element._getValidity()).to.equal(false);
          });
          it('should set validationErrors.maxlength based on value.length and maxlength', () => {
            element.value = 'value';
            element._getValidity();
            expect(element.validationErrors.maxlength).to.equal(false);
            element.maxlength = 3;
            element._getValidity();
            expect(element.validationErrors.maxlength).to.equal(true);
          });
          it('should set validationErrors.minlength based on value.length and minlength', () => {
            element.value = 'value';
            element.minlength = 1;
            element._getValidity();
            expect(element.validationErrors.minlength).to.equal(false);
            element.minlength = 8;
            element._getValidity();
            expect(element.validationErrors.minlength).to.equal(true);
          });
          it('should set validationErrors.minUpper based on value containing minUpper+ uppercase', () => {
            element.value = 'value';
            element.minUpper = 0;
            element._getValidity();
            expect(element.validationErrors.minUpper).to.equal(false);
            element.minUpper = 2;
            element._getValidity();
            expect(element.validationErrors.minUpper).to.equal(true);
            element.value = 'ValUe';
            element._getValidity();
            expect(element.validationErrors.minUpper).to.equal(false);
          });
          it('should set validationErrors.minLetters based on value containing minLetters+ letters', () => {
            element.value = 'Valu3';
            element.minLetters = 0;
            element._getValidity();
            expect(element.validationErrors.minLetters).to.equal(false);
            element.minLetters = 4;
            element._getValidity();
            expect(element.validationErrors.minLetters).to.equal(false);
            element.minLetters = 5;
            element._getValidity();
            expect(element.validationErrors.minLetters).to.equal(true);
          });
          it('should set validationErrors.minNumbers based on value containing minNumbers+ numbers', () => {
            element.value = '1a2b3c';
            element.minNumbers = 0;
            element._getValidity();
            expect(element.validationErrors.minNumbers).to.equal(false);
            element.minNumbers = 2;
            element._getValidity();
            expect(element.validationErrors.minNumbers).to.equal(false);
            element.minNumbers = 4;
            element._getValidity();
            expect(element.validationErrors.minNumbers).to.equal(true);
          });
          it('should set validationErrors.minSymbols based on value containing minSymbols+ allowedSymbols', () => {
            element.value = 'v@lu3';
            element.minSymbols = 0;
            element._getValidity();
            expect(element.validationErrors.minSymbols).to.equal(false);
            element.value = 'v@lu3';
            element.minSymbols = 1;
            element._getValidity();
            expect(element.validationErrors.minSymbols).to.equal(false);
            element.minSymbols = 2;
            element._getValidity();
            expect(element.validationErrors.minSymbols).to.equal(true);
          });
          it('should set validationErrors.matching based on value matching retypeValue and !disableRetype', () => {
            element.value = 'value';
            element.retypeValue = 'value';
            element._getValidity();
            expect(element.validationErrors.matching).to.equal(false);
            element.retypeValue = '';
            element._getValidity();
            expect(element.validationErrors.matching).to.equal(true);
            element.disableRetype = true;
            element._getValidity();
            expect(element.validationErrors.matching).to.equal(false);
          });
        });
      });
    </script>
  </body>
</html>
