<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../mtz-utils/mtz-validatable-parent-behavior.html">

<script>
  // Ensure the namespace exists
  window.mtz = window.mtz || {};

  /**
   * Use `mtz.UpdatePasswordBehavior` the functionality behind `<mtz-update-password>` designed to validate
   *  a password against minimum requirements that are passed in, defaults to what UDM expects "out of the
   *  box".
   *
   * @polymerBehavior mtz.UpdatePasswordBehavior
   */
  mtz.UpdatePasswordBehavior = [mtz.ValidatableParentBehavior, {
    properties: {
      /* Allowed characters regex pattern, gets combined with symbols to build allowedPattern */
      allowedCharacters: {
        type: String,
        value: 'a-zA-Z0-9',
      },
      /* Allowed symbols regex pattern, gets combined with characters to build allowedPattern */
      allowedSymbols: {
        type: String,
        value: '\\.\\+\\-!;:@#\\$%\\^&\\*\\(\\)_=',
      },
      /* Removes the requirement for entering a password twice */
      disableRetype: {
        type: Boolean,
        value: false,
      },
      /* Maximum number of characters allowed */
      maxlength: {
        type: Number,
        value: 20,
      },
      /* Minimum number of characters required */
      minlength: {
        type: Number,
        value: 8,
      },
      /* Minimum number of capital letters required */
      minUpper: {
        type: Number,
        value: 0,
      },
      /* Minimum number of letters required, regardless of case */
      minLetters: {
        type: Number,
        value: 2,
      },
      /* Minimum number of numbers required */
      minNumbers: {
        type: Number,
        value: 2,
      },
      /* Minimum number of symbols required, valid symbols are defined by the symbols property */
      minSymbols: {
        type: Number,
        value: 0,
      },
      /* The second user entered password to validate against */
      retypeValue: {
        type: String,
        // Utilizes the mtz.ValidatableParentBehavior to trigger validation updates for retypeValue changes
        observer: '_valueChanged',
      },
      required: {
        type: Boolean,
        value: false,
      },
      /* Contains flags for all properties currently in error state */
      validationErrors: {
        type: Object,
        notify: true,
        value() {
          return {
            maxlength: true,
            minlength: true,
            minUpper: true,
            minLetters: true,
            minNumbers: true,
            minSymbols: true,
            matching: true,
          };
        },
      },
      validationMessages: {
        type: Array,
        value() {
          return [
            {
              key: 'matching',
              message: 'Passwords must match',
            },
            {
              key: 'maxlength',
              message: 'A maximum of ${maxlength} characters',
            },
            {
              key: 'minlength',
              message: 'A minimum of ${minlength} characters',
            },
            {
              key: 'minUpper',
              message: 'At least ${minUpper} uppercase',
            },
            {
              key: 'minLetters',
              message: 'At least ${minLetters} ${lettersText}',
            },
            {
              key: 'minNumbers',
              message: 'At least ${minNumbers} ${numbersText}',
            },
            {
              key: 'minSymbols',
              message: 'At least ${minSymbols} ${symbolsText}',
            },
          ];
        },
      },
      /**
       * The values to pass to the `<mtz-validation-status>` element, constructed from the flags.
       *
       * @protected
       */
      _validationValues: {
        type: Object,
        computed: `_buildValidationValues(allowedCharacters, allowedSymbols, maxlength, minlength, minUpper,
          minLetters, minNumbers, minSymbols)`,
      },
    },
    ready() {
      this.validate = this.validate.bind(this);
    },
    attached() {
      this.addEventListener('change', this.validate);
    },
    detached() {
      this.removeEventListener('change', this.validate);
    },
    /**
     * Constructs the _validationValues object from the requirements.
     *
     * @protected
     * @param {String} allowedCharacters
     * @param {String} allowedSymbols
     * @param {Number} maxlength
     * @param {Number} minlength
     * @param {Number} minUpper
     * @param {Number} minLetters
     * @param {Number} minNumbers
     * @param {Number} minSymbols
     * @return {Object}
     */
    _buildValidationValues(allowedCharacters, allowedSymbols, maxlength, minlength, minUpper, minLetters,
      minNumbers, minSymbols) {
      return {
        allowedCharacters,
        allowedSymbols,
        maxlength,
        minlength,
        minUpper,
        minLetters,
        minNumbers,
        minSymbols,
        lettersText: minLetters > 1 ? 'letters' : 'letter',
        numbersText: minNumbers > 1 ? 'numbers' : 'number',
        symbolsText: minSymbols > 1 ? 'symbols' : 'symbol',
      };
    },
    /**
     * Strips out the matching key from validationMessages when disableRetype.
     *
     * @protected
     * @param {Boolean} disableRetype
     * @param {Object} validationMessages
     * @return {Object}
     */
    _getValidationMessages(disableRetype, validationMessages) {
      if (disableRetype) {
        const index = validationMessages.findIndex((item) => item.key === 'matching');
        if (index >= 0) validationMessages.splice(index, 1);
      }
      return disableRetype ?
        validationMessages.filter((msg) => msg.key !== 'matching') :
        validationMessages;
    },
    /**
     * Overrides the default functionality for validation on this element.  Takes all requirements into account.
     *
     * @protected
     * @param {String} value
     * @return {Boolean} - true if value is valid
     */
    _getValidity() {
      const value = this.value || '';

      this.set('validationErrors', {
        maxlength: value.length > this.maxlength,
        minlength: value.length < this.minlength,
        minUpper: (value.match(/[A-Z]/g) || []).length < this.minUpper,
        minLetters: (value.match(/[a-z]/gi) || []).length < this.minLetters,
        minNumbers: (value.match(/\d/g) || []).length < this.minNumbers,
        minSymbols:
          (value.match(new RegExp(`[${this.allowedSymbols}]`, 'g')) || []).length < this.minSymbols,
        matching: !this.disableRetype && Boolean(this.value) && this.value !== this.retypeValue,
      });

      // Perform initial validation check of password (handles required and such)
      this.$.password.validate();
      // Validate retype password (checks against the generated matching pattern)
      const retypeInput = this.$$('#retype-password');
      if (retypeInput) retypeInput.validate();

      const error = Object.keys(this.validationErrors).some((key) => key !== 'matching' && this.validationErrors[key]);
      const matchingError = this.validationErrors.matching;

      // Handle custom validation based on the possible error cases for password, updates invalid if needed
      if ((value && error) || (!value && this.required)) {
        this.$.password.$.input.setAttribute('invalid', '');
      }

      return value ?
        !(error || matchingError) :
        !this.required;
    },
  }];
</script>
